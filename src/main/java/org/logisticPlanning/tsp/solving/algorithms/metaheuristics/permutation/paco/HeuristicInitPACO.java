package org.logisticPlanning.tsp.solving.algorithms.metaheuristics.permutation.paco;

import java.io.PrintStream;

import org.logisticPlanning.tsp.benchmarking.instances.Instance;
import org.logisticPlanning.tsp.benchmarking.objective.ObjectiveFunction;
import org.logisticPlanning.tsp.solving.Individual;
import org.logisticPlanning.tsp.solving.TSPAlgorithmRunner;
import org.logisticPlanning.tsp.solving.TSPModule;
import org.logisticPlanning.tsp.solving.algorithms.heuristics.TSPHeuristic;
import org.logisticPlanning.tsp.solving.algorithms.heuristics.TSPHeuristicWithStartNode;
import org.logisticPlanning.tsp.solving.algorithms.heuristics.doubleEndedNearestNeighbor.DoubleEndedNearestNeighborHeuristic;
import org.logisticPlanning.tsp.solving.algorithms.heuristics.edgeGreedy.EdgeGreedyHeuristic;
import org.logisticPlanning.tsp.solving.algorithms.heuristics.mst.MSTHeuristic;
import org.logisticPlanning.tsp.solving.algorithms.heuristics.nearestNeighbor.NearestNeighborHeuristic;
import org.logisticPlanning.tsp.solving.algorithms.heuristics.savings.SavingsHeuristic;
import org.logisticPlanning.tsp.solving.algorithms.metaheuristics.permutation.heuristicInitMA.PermutationHeuristicInitMA;
import org.logisticPlanning.tsp.solving.utils.NodeManager;
import org.logisticPlanning.utils.config.Configurable;
import org.logisticPlanning.utils.config.Configuration;
import org.logisticPlanning.utils.math.random.Randomizer;

/**
 *
 <p>
 * A version of the {@link PACO Population-based ACO} where the first
 * population is initialized with different heuristic methods.
 * </p>
 * <h2 id="paco">Population-based ACO</h2>
 * <p>
 * The Population-based <a href=
 * "https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms"
 * >ACO</a> algorithm (pACO)&nbsp;[<a href="#cite_G2004AAISAMCE"
 * style="font-weight:bold">1</a>, <a href="#cite_GM2002APBAFA"
 * style="font-weight:bold">2</a>, <a href="#cite_GM2002APBATDOP"
 * style="font-weight:bold">3</a>] is a version of the Ant Colony
 * Optimization Algorithm that does not require the presence and updating
 * of a complete pheromone matrix in memory. Instead, it maintains a set
 * (&quot;population&quot;) of {@code k} ants (paths, solutions,
 * permutations) which in their describe the pheromone information &#964;
 * completely. The efficiency of this algorithm has been verified
 * in&nbsp;[<a href="#cite_OHSRD2011ADAOTPBACOAFTTATQ"
 * style="font-weight:bold">4</a>, <a
 * href="#cite_OHSRD2011ADAOTPBACOAFTTATQ2"
 * style="font-weight:bold">5</a>].
 * </p>
 * <p>
 * <a href=
 * "https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms">Ant
 * Colony Optimization</a> has been introduced by Dorigo&nbsp;[<a
 * href="#cite_D1992OLANA" style="font-weight:bold">6</a>, <a
 * href="#cite_DS2004ACO" style="font-weight:bold">7</a>, <a
 * href="#cite_DB2005ACO" style="font-weight:bold">8</a>, <a
 * href="#cite_DBS2006ACOAAAACIT" style="font-weight:bold">9</a>, <a
 * href="#cite_DGMS2002SCOACO" style="font-weight:bold">10</a>]. In ACO,
 * solutions are generated by a constructive heuristic. The constructive
 * heuristic proceeds as follows: A simulated ant starts at a node in a
 * graph. It will decide to which node to move next based on two pieces on
 * information assigned to each edge: a static heuristic value assigned to
 * the edge and a &quot;pheromone&quot; value assigned to the edge which
 * may be modified. The ant continues to move until it reaches a
 * destination node. In TSPs, this means that it will visit all nodes. In
 * each of the algorithm's rounds, several solutions are created by
 * applying the heuristic/ant simulation process. At the end of the
 * iteration, the pheromones on the edges will be updated: If a solution
 * was particularly well, then the pheromones of the edges it includes will
 * be increased and thus, make the edge more likely to be visited by ants
 * in the future round. The pheromones in plain ACO are stored in a matrix
 * of {@code n*n} elements, but in pACO, only {@code k*n} elements are
 * necessary, with {@code k<<n}.
 * </p>
 * <p>
 * The idea of pACO is that each edge in each of these {@code k} solutions
 * contributes exactly an amount &#916; to the amount of pheromone on that
 * edge. If an ant/solution {@code x} enters the population, &#916;
 * pheromone is added to each edge in {@code x}. Vice versa, if an ant
 * leaves the population, for instance because it was replaced by another
 * younger or better ant, exactly this amount of pheromone is subtracted
 * again from the pheromone value of all of its edges. No other negative
 * update (like vaporization or something) is necessary.
 * </p>
 * <h2 id="heurInit">Heuristic Initialization</h2>
 * <p>
 * The first population used by this pACO variant is
 * {@link org.logisticPlanning.tsp.solving.algorithms.metaheuristics.permutation.paco.HeuristicInitPACO#createInitialPopulation(org.logisticPlanning.tsp.solving.Individual[], ObjectiveFunction)
 * initialized} using heuristic procedures such as
 * </p>
 * <ol>
 * <li>the
 * {@link org.logisticPlanning.tsp.solving.algorithms.heuristics.mst.MSTHeuristic
 * double minimum spanning tree method},</li>
 * <li>the
 * {@link org.logisticPlanning.tsp.solving.algorithms.heuristics.edgeGreedy.EdgeGreedyHeuristic
 * edge greedy method},</li>
 * <li>the
 * {@link org.logisticPlanning.tsp.solving.algorithms.heuristics.savings.SavingsHeuristic
 * savings heuristic},</li>
 * <li>the
 * {@link org.logisticPlanning.tsp.solving.algorithms.heuristics.doubleEndedNearestNeighbor.DoubleEndedNearestNeighborHeuristic
 * double-ended nearest neighbor heuristic}, and</li>
 * <li>the
 * {@link org.logisticPlanning.tsp.solving.algorithms.heuristics.nearestNeighbor.NearestNeighborHeuristic
 * nearest neighbor heuristic}.</li>
 * </ol>
 * <p>
 * The first two heuristics each contribute one solution to the initial
 * population. The latter three heuristics are instances of
 * {@link org.logisticPlanning.tsp.solving.algorithms.heuristics.TSPHeuristicWithStartNode}
 * , which can potentially produce up to {@code n} different solutions in
 * {@code n}-node TSPs. Therefore, we use these to fill up the population
 * and try to invoke them with different, random initial nodes. This should
 * lead to initial population which is diverse and still contains
 * reasonably good solutions.
 * </p>
 * <h2>References</h2>
 * <ol>
 * <li><div><span id="cite_G2004AAISAMCE" /><a
 * href="http://www.aifb.kit.edu/web/Michael_Guntsch/en">Michael
 * Guntsch</a>: <span
 * style="font-style:italic;font-family:cursive;">&ldquo;Ant Algorithms in
 * Stochastic and Multi-Criteria Environments,&rdquo;</span> PhD Thesis,
 * January&nbsp;13, 2004, Karlsruhe, Germany: University of Karlsruhe
 * (Friedriciana), Department of Economics and Business Engineering
 * and&nbsp;Karlsruhe, Germany: University of Karlsruhe (Friedriciana),
 * Institute for Applied Computer Science and Formal Description Methods
 * (AIFB). Google Book ID:&nbsp;<a
 * href="http://books.google.com/books?id=Lf1ztwAACAAJ">Lf1ztwAACAAJ</a>.
 * <div>links: [<a
 * href="http://www.lania.mx/~ccoello/EMOO/thesis_guntsch.pdf.gz">1</a>]
 * and&nbsp;[<a
 * href="http://digbib.ubka.uni-karlsruhe.de/volltexte/212004">2</a>];
 * urn:&nbsp;<a href=
 * "http://wm-urn.org/?urn=urn:nbn:de:swb:90-AAA2120045&amp;redirect=1"
 * >urn:nbn:de:swb:90-AAA2120045</a></div></div></li>
 * <li><div><span id="cite_GM2002APBAFA" /><a
 * href="http://www.aifb.kit.edu/web/Michael_Guntsch/en">Michael
 * Guntsch</a> and&nbsp;<a href=
 * "http://pacosy.informatik.uni-leipzig.de/15-0-Prof+Dr+Martin+Middendorf.html"
 * >Martin Middendorf</a>: <span style="font-weight:bold">&ldquo;A
 * Population Based Approach for ACO,&rdquo;</span> in <span
 * style="font-style:italic;font-family:cursive;">Applications of
 * Evolutionary Computing, Proceedings of EvoWorkshops 2002: EvoCOP,
 * EvoIASP, EvoSTIM/EvoPLAN (EvoWorkshops'02)</span>, April&nbsp;2&ndash;4,
 * 2002, Kinsale, Ireland, pages 72&ndash;81, <a
 * href="http://www.ce.unipr.it/people/cagnoni/">Stefano Cagnoni</a>, Jens
 * Gottlieb, <a
 * href="http://www.soc.napier.ac.uk/~emmah/Prof_Emma_Hart/Welcome.html"
 * >Emma Hart</a>, <a href=
 * "http://pacosy.informatik.uni-leipzig.de/15-0-Prof+Dr+Martin+Middendorf.html"
 * >Martin Middendorf</a>, and&nbsp;<a
 * href="https://www.ads.tuwien.ac.at/raidl/">G&#252;nther R. Raidl</a>,
 * editors, volume 2279 of Lecture Notes in Computer Science (LNCS),
 * Berlin, Germany: Springer-Verlag GmbH. ISBN:&nbsp;<a
 * href="https://www.worldcat.org/isbn/3540434321">3-540-43432-1</a>
 * and&nbsp;<a
 * href="https://www.worldcat.org/isbn/9783540434320">978-3-540-
 * 43432-0</a>; doi:&nbsp;<a
 * href="http://dx.doi.org/10.1007/3-540-46004-7_8"
 * >10.1007/3-540-46004-7_8</a>; ISSN:&nbsp;<a
 * href="https://www.worldcat.org/issn/03029743">0302-9743</a> and&nbsp;<a
 * href="https://www.worldcat.org/issn/16113349">1611-3349</a>.
 * <div>CiteSeer<sup>x</sup><sub
 * style="font-style:italic">&#946;</sub>:&nbsp;<a href
 * ="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.2514"
 * >10.1.1.13 .2514</a></div></div></li>
 * <li><div><span id="cite_GM2002APBATDOP" /><a
 * href="http://www.aifb.kit.edu/web/Michael_Guntsch/en">Michael
 * Guntsch</a> and&nbsp;<a href=
 * "http://pacosy.informatik.uni-leipzig.de/15-0-Prof+Dr+Martin+Middendorf.html"
 * >Martin Middendorf</a>: <span style="font-weight:bold">&ldquo;Applying
 * Population Based ACO to Dynamic Optimization Problems,&rdquo;</span> in
 * <span style="font-style:italic;font-family:cursive;">From Ant Colonies
 * to Artificial Ants &#8210; Proceedings of the Third International
 * Workshop on Ant Colony Optimization (ANTS'02)</span>,
 * September&nbsp;12&ndash;14, 2002, Brussels, Belgium, pages
 * 111&ndash;122, <a
 * href="https://en.wikipedia.org/wiki/Marco_Dorigo">Marco Dorigo</a>, <a
 * href="http://www.idsia.ch/~gianni/">Gianni A. Di Caro</a>,
 * and&nbsp;Michael Samples, editors, volume 2463/2002 of Lecture Notes in
 * Computer Science (LNCS), Berlin, Germany: Springer-Verlag GmbH.
 * ISBN:&nbsp;<a
 * href="https://www.worldcat.org/isbn/3540441468">3-540-44146-8</a>
 * and&nbsp;<a
 * href="https://www.worldcat.org/isbn/9783540441465">978-3-540-
 * 44146-5</a>; doi:&nbsp;<a
 * href="http://dx.doi.org/10.1007/3-540-45724-0_10">10.1007/3-540-45724
 * -0_10</a>; ISSN:&nbsp;<a
 * href="https://www.worldcat.org/issn/03029743">0302-9743</a> and&nbsp;<a
 * href="https://www.worldcat.org/issn/16113349">1611-3349</a>.
 * <div>CiteSeer<sup>x</sup><sub
 * style="font-style:italic">&#946;</sub>:&nbsp;<a href
 * ="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.12.6580"
 * >10.1.1.12 .6580</a></div></div></li>
 * <li><div><span id="cite_OHSRD2011ADAOTPBACOAFTTATQ" />Sabrina M.
 * Oliveira, Mohamed Saifullah Hussin, <a
 * href="http://iridia.ulb.ac.be/~stuetzle/">Thomas St&#252;tzle</a>,
 * Andrea Roli, and&nbsp;<a
 * href="https://en.wikipedia.org/wiki/Marco_Dorigo">Marco Dorigo</a>:
 * <span style="font-weight:bold">&ldquo;A Detailed Analysis of the
 * Population-based Ant Colony Optimization Algorithm for the TSP and the
 * QAP,&rdquo;</span> <span
 * style="font-style:italic;font-family:cursive;">Technical Report</span>
 * Number&nbsp;TR/IRIDIA/2011-006, February&nbsp;2011; published by
 * Brussels, Belgium: Universit&#233; Libre de Bruxelles, Institut de
 * Recherches Interdisciplinaires et de D&#233;veloppements en Intelligence
 * Artificielle (IRIDIA). ISSN:&nbsp;<a
 * href="https://www.worldcat.org/issn/17813794">1781-3794</a>. <div>link:
 * [<a href
 * ="http://iridia.ulb.ac.be/IridiaTrSeries/rev/IridiaTr2011-006r001.pdf"
 * >1</ a>]</div></div></li>
 * <li><div><span id="cite_OHSRD2011ADAOTPBACOAFTTATQ2" />Sabrina M.
 * Oliveira, Mohamed Saifullah Hussin, <a
 * href="http://iridia.ulb.ac.be/~stuetzle/">Thomas St&#252;tzle</a>,
 * Andrea Roli, and&nbsp;<a
 * href="https://en.wikipedia.org/wiki/Marco_Dorigo">Marco Dorigo</a>:
 * <span style="font-weight:bold">&ldquo;A Detailed Analysis of the
 * Population-based Ant Colony Optimization Algorithm for the TSP and the
 * QAP,&rdquo;</span> in <span
 * style="font-style:italic;font-family:cursive;">Proceedings of the
 * Genetic and Evolutionary Computation Conference (GECCO'11)</span>,
 * July&nbsp;12&ndash;16, 2011, Dublin, Ireland, pages 13&ndash;14.
 * doi:&nbsp;<a href="http://dx.doi.org/10.1145/2001858.2001866">10.1145/
 * 2001858.2001866</a>. <div>link: [<a
 * href="http://code.ulb.ac.be/dbfiles/OliHusStu-etal2011gecco.pdf"
 * >1</a>]</div></div></li>
 * <li><div><span id="cite_D1992OLANA" /><a
 * href="https://en.wikipedia.org/wiki/Marco_Dorigo">Marco Dorigo</a>:
 * <span
 * style="font-style:italic;font-family:cursive;">&ldquo;Optimization,
 * Learning and Natural Algorithms,&rdquo;</span> PhD Thesis,
 * January&nbsp;1992, Milano, Italy: Dipartimento di Elettronica,
 * Politecnico di Milano</div></li>
 * <li><div><span id="cite_DS2004ACO" /><a
 * href="https://en.wikipedia.org/wiki/Marco_Dorigo">Marco Dorigo</a>
 * and&nbsp;<a href="http://iridia.ulb.ac.be/~stuetzle/">Thomas
 * St&#252;tzle</a>: <span
 * style="font-style:italic;font-family:cursive;">&ldquo;Ant Colony
 * Optimization,&rdquo;</span> July&nbsp;1, 2004, Bradford Books,
 * Cambridge, MA, USA: MIT Press. ISBN:&nbsp;<a
 * href="https://www.worldcat.org/isbn/0262042193">0-262-04219-3</a>
 * and&nbsp;<a
 * href="https://www.worldcat.org/isbn/9780262042192">978-0-262-
 * 04219-2</a>; Google Book ID:&nbsp;<a
 * href="http://books.google.com/books?id=_aefcpY8GiEC"
 * >_aefcpY8GiEC</a></div></li>
 * <li><div><span id="cite_DB2005ACO" /><a
 * href="https://en.wikipedia.org/wiki/Marco_Dorigo">Marco Dorigo</a>
 * and&nbsp;Christian Blum: <span style="font-weight:bold">&ldquo;Ant
 * Colony Optimization Theory: A Survey,&rdquo;</span> in <span
 * style="font-style:italic;font-family:cursive;">Theoretical Computer
 * Science</span> 344(2-3), November&nbsp;17, 2005; published by Essex, UK:
 * Elsevier Science Publishers B.V.. doi:&nbsp;<a
 * href="http://dx.doi.org/10.1016/j.tcs.2005.05.020"
 * >10.1016/j.tcs.2005.05.020</a>; ISSN:&nbsp;<a
 * href="https://www.worldcat.org/issn/03043975">0304-3975</a>. <div>link:
 * [<a
 * href="http://code.ulb.ac.be/dbfiles/DorBlu2005tcs.pdf">1</a>]</div></
 * div></li>
 * <li><div><span id="cite_DBS2006ACOAAAACIT" /><a
 * href="https://en.wikipedia.org/wiki/Marco_Dorigo">Marco Dorigo</a>,
 * Mauro Birattari, and&nbsp;<a
 * href="http://iridia.ulb.ac.be/~stuetzle/">Thomas St&#252;tzle</a>: <span
 * style="font-weight:bold">&ldquo;Ant Colony Optimization &#8210;
 * Artificial Ants as a Computational Intelligence Technique,&rdquo;</span>
 * in <span style="font-style:italic;font-family:cursive;">IEEE
 * Computational Intelligence Magazine (CIM)</span> 1(4):28&ndash;39,
 * November&nbsp;2006; published by Piscataway, NJ, USA: IEEE Computational
 * Intelligence Society. doi:&nbsp;<a
 * href="http://dx.doi.org/10.1109/MCI.2006.329691"
 * >10.1109/MCI.2006.329691</a>; ISSN:&nbsp;<a
 * href="https://www.worldcat.org/issn/1556603X">1556-603X</a>; INSPEC
 * Accession Number:&nbsp;9184238. <div>links: [<a
 * href="http://iridia.ulb.ac.be/~mbiro/paperi/IridiaTr2006-023r001.pdf"
 * >1</a>] and&nbsp;[<a
 * href="http://iridia.ulb.ac.be/~mbiro/paperi/DorBirStu2006ieee-cim.pdf"
 * >2</a>]; CiteSeer<sup>x</sup><sub
 * style="font-style:italic">&#946;</sub>:&nbsp;<a
 * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.64.9532"
 * >10.1.1.64.9532</a></div></div></li>
 * <li><div><span id="cite_DGMS2002SCOACO" /><a
 * href="https://en.wikipedia.org/wiki/Marco_Dorigo">Marco Dorigo</a>, <a
 * href="http://www.idsia.ch/~luca/">Luca Maria Gambardella</a>, <a href=
 * "http://pacosy.informatik.uni-leipzig.de/15-0-Prof+Dr+Martin+Middendorf.html"
 * >Martin Middendorf</a>, and&nbsp;<a
 * href="http://iridia.ulb.ac.be/~stuetzle/">Thomas St&#252;tzle</a>: <span
 * style="font-weight:bold">&ldquo;Special Section on &#8220;Ant Colony
 * Optimization&#8221;,&rdquo;</span> in <span
 * style="font-style:italic;font-family:cursive;">IEEE Transactions on
 * Evolutionary Computation (IEEE-EC)</span> 6(4):317&ndash;365,
 * August&nbsp;2002; published by Washington, DC, USA: IEEE Computer
 * Society. LCCN:&nbsp;<a href="http://lccn.loc.gov/97648327">97648327</a>;
 * doi:&nbsp;<a href
 * ="http://dx.doi.org/10.1109/TEVC.2002.802446">10.1109/TEVC
 * .2002.802446</a>; ISSN:&nbsp;<a
 * href="https://www.worldcat.org/issn/1089778X">1089-778X</a> and&nbsp;<a
 * href="https://www.worldcat.org/issn/19410026">1941-0026</a>;
 * CODEN:&nbsp;<a href=
 * "http://www-library.desy.de/cgi-bin/spiface/find/coden/www?code=ITEVF5"
 * >ITEVF5</a>; further information: [<a
 * href="http://www.ieee-cis.org/pubs/tec/">1</a>]</div></li>
 * </ol>
 */
public class HeuristicInitPACO extends PACO {
  /** the serial version uid */
  private static final long serialVersionUID = 1L;

  /** the one-time initializers: {@value} */
  public static final String PARAM_INIT_ONCE = "oneTimeInitializers"; //$NON-NLS-1$

  /** the one-time rest: {@value} */
  public static final String PARAM_INIT_MULTI = "multiInitializers"; //$NON-NLS-1$

  /** the heuristics which are used exactly once */
  @SuppressWarnings("unchecked")
  private static final Class<? extends TSPHeuristic>[] INIT_ONCE = new Class[] {
      MSTHeuristic.class, EdgeGreedyHeuristic.class };

  /** the heuristics which are used exactly once */
  @SuppressWarnings("unchecked")
  private static final Class<? extends TSPHeuristicWithStartNode>[] INIT_MULTI = new Class[] {
      SavingsHeuristic.class, DoubleEndedNearestNeighborHeuristic.class,
      NearestNeighborHeuristic.class };

  /**
   * the heuristics used for initialization
   *
   * @serial an array of non-null instances
   */
  private TSPHeuristic[] m_initOnce;

  /**
   * the multi-times heuristic
   *
   * @serial an array of non-null instances
   */
  private TSPHeuristicWithStartNode[] m_initMulti;

  /**
   * instantiate
   */
  public HeuristicInitPACO() {
    this(null);
  }

  /**
   * instantiate
   *
   * @param name
   *          the name
   */
  protected HeuristicInitPACO(final String name) {
    super("Heuristic Init " + //$NON-NLS-1$
        ((name != null) ? name : "")); //$NON-NLS-1$

    int i;

    this.m_initOnce = new TSPHeuristic[i = HeuristicInitPACO.INIT_ONCE.length];
    for (; (--i) >= 0;) {
      try {
        this.m_initOnce[i] = HeuristicInitPACO.INIT_ONCE[i].newInstance();
      } catch (final Throwable t) {
        throw new RuntimeException(t);
      }
    }

    this.m_initMulti = new TSPHeuristicWithStartNode[i = HeuristicInitPACO.INIT_MULTI.length];
    for (; (--i) >= 0;) {
      try {
        this.m_initMulti[i] = HeuristicInitPACO.INIT_MULTI[i]
            .newInstance();
      } catch (final Throwable t) {
        throw new RuntimeException(t);
      }
    }
  }

  /**
   * This procedure creates the initial population by using the available,
   * various heuristics. Which heuristics are used will depend on the
   * population size and the available runtime. Also, each created
   * individual will be refined via
   * {@link #refineSolution(int[], long, ObjectiveFunction)}.
   *
   * @param pop
   *          the population to fill
   * @param f
   *          the objective function
   */
  @Override
  protected void createInitialPopulation(final Individual<int[]>[] pop,
      final ObjectiveFunction f) {
    int i;
    final int n;
    final Randomizer r;
    NodeManager m;
    Individual<int[]> ind;

    n = f.n();
    m = this.m_nodes;
    m.init(n);

    r = f.getRandom();

    for (i = pop.length; (--i) >= 0;) {
      if (f.shouldTerminate()) {
        return;
      }

      ind = pop[i];

      if (i >= this.m_initOnce.length) {
        if (m.size() <= 0) {
          m.init(n);
        }
        this.m_initMulti[r.nextInt(this.m_initMulti.length)].solve(f, ind,
            m.deleteRandom(r));
      } else {
        this.m_initOnce[i].solve(f, ind);
      }

      ind.tourLength = this
          .refineSolution(ind.solution, ind.tourLength, f);
    }
  }

  /** {@inheritDoc} */
  @Override
  public HeuristicInitPACO clone() {
    HeuristicInitPACO cfg;
    int i;

    cfg = ((HeuristicInitPACO) (super.clone()));

    cfg.m_initOnce = cfg.m_initOnce.clone();
    for (i = cfg.m_initOnce.length; (--i) >= 0;) {
      cfg.m_initOnce[i] = ((TSPHeuristic) (cfg.m_initOnce[i].clone()));
    }

    cfg.m_initMulti = cfg.m_initMulti.clone();
    for (i = cfg.m_initMulti.length; (--i) >= 0;) {
      cfg.m_initMulti[i] = ((TSPHeuristicWithStartNode) (cfg.m_initMulti[i]
          .clone()));
    }

    return cfg;
  }

  /** {@inheritDoc} */
  @Override
  public void printConfiguration(final PrintStream ps) {
    super.printConfiguration(ps);

    Configurable.printKey(PermutationHeuristicInitMA.PARAM_INIT_ONCE, ps);
    Configurable.printlnObject(this.m_initOnce, ps);

    Configurable.printKey(PermutationHeuristicInitMA.PARAM_INIT_MULTI, ps);
    Configurable.printlnObject(this.m_initMulti, ps);
  }

  /** {@inheritDoc} */
  @Override
  public void printParameters(final PrintStream ps) {
    super.printParameters(ps);

    for (final TSPHeuristic o : this.m_initOnce) {
      o.printParameters(ps);
    }

    for (final TSPHeuristic m : this.m_initMulti) {
      m.printParameters(ps);
    }
  }

  /** {@inheritDoc} */
  @Override
  public void configure(final Configuration config) {
    super.configure(config);

    for (final TSPHeuristic o : this.m_initOnce) {
      o.configure(config);
    }

    for (final TSPHeuristic m : this.m_initMulti) {
      m.configure(config);
    }
  }

  /**
   * Perform the population-based ACO
   *
   * @param args
   *          the command line arguments
   */
  public static void main(final String[] args) {
    TSPAlgorithmRunner.benchmark(//
        Instance.SYMMETRIC_INSTANCES, HeuristicInitPACO.class,//
        args);
  }

  /** {@inheritDoc} */
  @Override
  public void beginRun(final ObjectiveFunction f) {
    super.beginRun(f);
    TSPModule.invokeBeginRun(f, this.m_initOnce);
    TSPModule.invokeBeginRun(f, this.m_initMulti);
  }

  /** {@inheritDoc} */
  @Override
  public void endRun(final ObjectiveFunction f) {
    try {
      TSPModule.invokeEndRun(f, this.m_initMulti);
    } finally {
      try {
        TSPModule.invokeEndRun(f, this.m_initOnce);
      } finally {
        super.endRun(f);
      }
    }
  }
}
